<!DOCTYPE html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"></script>
  <style>
    body{
      background-color: black;
      margin:0;
      padding:0;
    }
    .btn{
      background-color: rgba(255,255,255,0.2);
      color: rgba(255,255,255,0.5);
      padding: 6px 15px;
      border: none;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="root">

  <button class="btn" @click="toggleInformation" style="position:fixed;">
    information
  </button>
  <div v-if="informationIsVisible" style="position:fixed; top:37px; background-color:rgba(0,0,0,0.85); padding:20px 50px; color:grey"> 
    <h3>General Information</h3>
    <p><strong>Basiclly this is a clock. It's real time, and slow moving.</strong> Would work great as a background, new tab, maybe a device face.</p>
    <p><strong>Has geolocation</strong>: you should have a magenta dot for where you are at, more on that later.</p>
    <p><strong>It tells the time of the day.</strong> Your dot, like your location, will experience sunrise and sunset, as it moves through the day.</p>
    <p><strong>Tells the day of the year.</strong> On January first the sun is directly to the left of the screen, and moves around the 'sun' counterclockwise.</p>
    <p>Find the triangle that represents dawn at the equator (moving from dark to light). The Earth spins while moving in that direction.</p>
    <p><strong>The shadow changes shape</strong>, in the winter the Earth moves a bit north making more hours there night. The shape of that shadow should be pretty accurate, depending of if I got the right projection.</p>
    <p>There isn't a direct day/night switch, but thought drawing a twilight region would add complexity and still be a guess. However, the size of your location dot is about how much of the sky you can see (ish). When your dot reaches a boundary, daylight will change, when the dot finishes the transition, the daylight will too.</p>
    <dl>
      <dt>Next up:</dt>
      <dd>Moon Location with shadow</dd>
      <dd>Nearby planets (the ones visible to the naked eye)</dd>
      <dd>Zodiac constellations</dd>
      <dd>Adding multiple locations that you want to track through the day.</dd>
      <dt>What about <em>xyz</em> Timezone or <em>Daylight savings</em></dt>
      <dd>The app's official position is that timezones are dumb, and daylight savings is even more dumb. The 'clock markings' represet sun-time, not Earth time. You can find the zenith of the sun, but that may not be noon where you are. That is not the purpose of this clock.</dd>
      <dt>disclaimers:</dt>
      <dd>None of this is to scale. Yes, my math could be better, objects could be up to 1/5 degree off (depending on day of year), but these shouldn't get too bad until about 2050.</dd>
    </dl>
  </div>

  <svg height="800" width="800" :view-box.camel="viewBoxString">
    <defs>
      <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="4" height="4">
        <rect width="5" height="5" style="fill:rgba(0,0,0,0.2);" />
        <path d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" style="stroke:rgba(0,0,0,0.4); stroke-width:1" />
      </pattern>

      <clipPath id="winter">
        <ellipse cx="400" cy="400" rx="200" :ry="shadowEllipseHeight" id="winterNightEllipse"/>
        <path d="M200,400 a1,1 0 0,0 400,0" />
      </clipPath>

      <mask id="summer">
        <circle cx="400" cy="400" r="200" fill="white"></circle>
        <ellipse cx="400" cy="400" rx="200" :ry="Math.abs(shadowEllipseHeight)" fill="black" id="summerNightEllipse"></ellipse>
        <path d="M200,400 a1,1 0 0,1 400,0" fill="black"></path>
      </mask>
    </defs>
    
    <image width="400" height="400" x="200" y="200" xlink:href="./earth3.png" id="cartoonEarth" :transform="timeBasedRotation"/>

    <g fill="rgba(255,255,255,0.0)" 
    stroke-width="2" 
    id="locationPins" 
    :transform="timeBasedRotation">
      <g v-for="(location,i) in locations" :key="i" :stroke="location.color" >
        <circle 
          :cx="latLongToX(location)"
          :cy="latLongToY(location)"
          r="4" stroke-width="2"></circle>
        <circle  cx="400" cy="400" :r="pinLoop(location)" stroke-width="1" stroke-opacity="0.8" stroke-dasharray="5,5"></circle>
      </g>
    </g>
  
    <g :transform="dayBasedRotation">
      <rect width="400" height="400" x="200" y="200" 
        v-if="shadowEllipseHeight > 0"
        fill="url(#diagonalHatch)" 
        clip-path="url(#winter)" 
        id="winterNight" />
      <rect width="300" height="300" x="5" y="5" 
        v-else
        fill="url(#diagonalHatch)" 
        mask="url(#summer)" 
        id="summerNight" />
    </g>

    <g id="hourMarkers" :transform="dayBasedRotation">
      <g id="interval-l" >
        <g id="interval-m">
          <path d="M190,400 l10,-2 0,4 Z" fill="rgba(255,255,255,0.5)"></path>
          <circle cx="202" cy="400" r="3" fill="rgba(255,255,255,0.5)"></circle>
          <line x1="200" x2="600" y1="400" y2="400" stroke-width="1" stroke="rgba(255,255,255,0.1)"></line>
          <circle cx="599" cy="400" r="3" fill="rgba(255,255,255,0.5)"></circle>
          <path d="M611,400 l-10,-2 0,4 Z" fill="rgba(255,255,255,0.5)"></path>
        </g>
        <g id="interval-s" transform="rotate(15 400 400)">
          <path d="M200,400 l-4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
          <path d="M600,400 l4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
        </g>
        <g id="interval-s" transform="rotate(30 400 400)">
          <path d="M200,400 l-4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
          <path d="M600,400 l4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
        </g>
        <g id="interval-s" transform="rotate(45 400 400)">
          <path d="M200,400 l-4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
          <path d="M600,400 l4,-4 0,8 Z" fill="rgba(255,255,255,0.4)"></path>
        </g>
      </g>'
      <g transform="rotate(60 400 400)">
          <use xlink:href='#interval-l'/>
      </g>
      <g transform="rotate(120 400 400)">
          <use xlink:href='#interval-l'/>
      </g>
    </g>
  
  </svg>

  <br/>
  <button class="btn" @click="updateLocal">
    local pin
  </button>

  </div>


<script type="text/javascript">

const planets = {
  /*
  a: semi-major axis
  e: eccentricity
  i: inclination
  O: longitude of ascending node
  p: longitude of perihelion
  L: mean longitude
  n: mean daily motion
  */
  Mercury:{
    a: 0.38709893,
    e: 0.20563069,
    i: 7.00487,
    O: 48.33167,
    p: 77.45645,
    L: 252.25084,
    n: 4.092353,
  },
  Venus:{
    a: 0.72333199,
    e: 0.00677323,
    i: 3.39471,
    O: 76.68069,
    p: 131.53298,
    L: 181.97973,
    n: 1.602158,
  },
  Earth:{
    a: 1.00000011,
    e: 0.01671022,
    i: 0.00005,
    O: -11.26064,
    p: 102.94719,
    L: 100.46435,
    n: 0.9855796,
  },
  Mars:{
    a: 1.52366231,
    e: 0.09341233,
    i: 1.85061,
    O: 49.57854,
    p: 336.04084,
    L: 355.45332,
    n: 0.5240613,
  },
  Jupiter:{
    a: 5.20336301,
    e: 0.04839266,
    i: 1.30530,
    O: 100.55615,
    p: 14.75385,
    L: 34.40438,
    n: 0.008309618,
  },
  Saturn:{
    a: 9.53707032,
    e: 0.05415060,
    i: 2.48446,
    e: 113.71504,
    O: 92.43194,
    p: 49.94432,
    n: 0.03328656,
  },
}

  const msPerDay = (1000 * 60 * 60 * 24);
  const toRad = (180 / Math.PI); 
  function mod(n, m) {
    return ((n % m) + m) % m;
  }
  function sin(n){
    return Math.sin(n*toRad);
  }
  function cos(n){
    return Math.cos(n*toRad);
  }

  var app = new Vue({
    el: '#root',
    data(){
      const d = new Date();//new Date('6 20, 2000 12:00:0000 GMT+00:00');
      return {
        //exactDay: new Date(),
        exactDay: d,
        currYear: d.getFullYear(),
        J2000: 946728000000, //UTC time of 2000-01-01 12:00:00 GMT+00:00
        stableQuarterDay: this.findQuarterDay(d),
        degPerRadian: (180 / Math.PI),
        earthRadiusPx: 150,
        locations: {},
        timer: undefined,
        viewBoxString: '0 0 800 800',
        informationIsVisible: false,
      }
    },
    mounted(){
      if(localStorage.getItem('cities') !== null){
        this.locations = JSON.parse(localStorage.getItem('cities'))
      }else{
        this.updateLocal();
      }
      this.timer = setInterval( () => {
        this.exactDay = new Date();
      }, 20*1000);
    },
    watch:{
      exactDay(newDay, oldDay){
        let d = this.findQuarterDay(newDay);
        if(this.stableQuarterDay != d) this.stableQuarterDay = Number(d);
      },
    },
    computed:{
      earthAnomoly(){
        console.log('reran earthAnomoly');
        return this.findHeliocentricAnomoly(planets.Earth, this.stableQuarterDay);
      },
      dayBasedRotation(){
        console.log('reran dayBasedRotation', (-90-this.earthAnomoly).toFixed(2));
        return `rotate(${(-90-this.earthAnomoly).toFixed(2)} 400 400)`;
      },
      timeBasedRotation(){
        let partialDayHrs = mod( (this.exactDay.getTime() - this.J2000)/(1000*60*60), 24);
        let earthRot =  mod(-270 - this.earthAnomoly - (partialDayHrs*15), 360);
        console.log('reran timeBasedRotation', earthRot);
        return `rotate(${earthRot} 400 400)`
      },
      shadowEllipseHeight(){
        var start = new Date(this.currYear, 0, 0);
        var diff = this.stableQuarterDay - (start/msPerDay);
        var day = Math.floor(diff);
        //console.log('day of year', day);
        //day 1 is Vernal Equinox
        console.log('reran shadowEllipseHeight', this.earthRadiusPx * 0.235 * -Math.sin( (day-79) * (Math.PI/180) ));
        return this.earthRadiusPx * 0.235 * -Math.sin( (day-79) * (Math.PI/180) );
      }
    },
    methods:{
      findQuarterDay(d){
        let dayNum = d.getTime() / msPerDay;
        //console.log('reran quarterDay', (Math.round(dayNum * 4) / 4).toFixed(2));
        var quarter =  (Math.round(dayNum * 4) / 4).toFixed(2);
        console.log('quarter', quarter);
        return Number(quarter);
        //if(this.stableQuarterDay != quarter) this.stableQuarterDay = Number(quarter);
      },
      findHeliocentricAnomoly(body, qDay){
        let dayDiff = qDay - (this.J2000 / msPerDay);
        
        var meanAnomoly = mod( (body.n * dayDiff + body.L - body.p), 360);
        //console.log('mean anomoly', meanAnomoly);

        var trueAnomoly = meanAnomoly + this.degPerRadian * (
          ((2 * body.e - Math.pow(body.e, 3)/4) * sin(meanAnomoly)) +
          (5/4 * Math.pow(body.e, 2) * sin(2*meanAnomoly)) +
          (13/12 * Math.pow(body.e, 3) * sin(3*meanAnomoly))
        );
        //console.log('true anomoly', trueAnomoly);
        return trueAnomoly;
      },
      latLongToX(location){
        let theta = (90-location.long) * Math.PI / 180;
        let radius = 200 * (1 - (location.lat/90));
        return 400 + radius * Math.cos(theta);
      },
      latLongToY(location){
        let theta = (90-location.long) * Math.PI / 180;
        let radius = 200 * (1 - (location.lat/90));
        return 400 + radius * Math.sin(theta);
      },
      updateLocal(){
        navigator.geolocation.getCurrentPosition( pos => {
          console.log(pos);
          this.$set(this.locations, 'local', {
            lat: pos.coords.latitude,
            long: pos.coords.longitude,
            color: 'magenta',
          });
          localStorage.setItem('cities', JSON.stringify(this.locations));
        });
      },
      pinLoop(location){
        return 200 * (1 - (location.lat/90));
      },
      toggleInformation(){
        this.informationIsVisible = !this.informationIsVisible;
      }
    }
  });

  
</script>
</body>
</html>
